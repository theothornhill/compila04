import java_cup.runtime.*;
import java.io.FileReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.ByteArrayInputStream;
import java.util.*;

parser code
{:
public void syntax_error(Symbol s) {
    System.err.printf("compiler has detected a syntax error: [%s]\n", s.value);
}
:};

scan with {: return getScanner().next_token(); :};

terminal                           PROGRAM;
terminal                           BEGIN, END;
terminal                           LPAR, RPAR, SEMI;
terminal                           REC_DECL, PROC_DECL, VAR_DECL, NEW;
terminal                           IF, FI, THEN, ELSE, WHILE, DO, OD, RETURN, REF, DEREF;
terminal                           INT_LITERAL, STRING_LITERAL, FLOAT_LITERAL;
terminal                           TRUE, FALSE, NULL;
terminal                           DOT, PARAM_ID, ASSIGN_OP;
terminal                           NOT;
terminal                           LT, LTEQ, GT, GTEQ, EQ, NEQ;
terminal                           ADD, MINUS, MULT, DIVIDE, EXPONENT;
terminal                           AND, OR;
terminal                           FLOAT, INT, STRING, BOOL;
terminal String                    NAME;
nonterminal                        literal, call_stmt;
nonterminal                        stmts, stmt, assign_stmt, if_stmt, while_stmt;
nonterminal                        return_stmt;
nonterminal Program                program;
nonterminal String                 decl, type;
nonterminal String                 rel_op, log_op, arit_op;
nonterminal String                 exp, bool, var, ref_var, deref_var;
nonterminal LinkedList<String>     decl_list;

precedence left                    OR;
precedence left                    AND;
precedence right                   NOT;
precedence nonassoc                LT, LTEQ, GT, GTEQ, EQ, NEQ;
precedence left                    ADD, MINUS;
precedence left                    MULT, DIVIDE;
precedence right                   EXPONENT;
precedence left                    DOT;

start with program;

program           ::=  PROGRAM NAME:name BEGIN decl_list:dl END
                               {: LinkedList<LinkedList> l = new LinkedList<>();
                                  l.add(dl);
                                  RESULT = new Program(name, l);
                                  System.out.println(RESULT.printAst()); :}
                   ;

decl_list         ::= decl:d {: LinkedList<String> l = new LinkedList<>();
                                l.add(d);
                                RESULT = l; :}
                    |   decl_list:dl decl:d
                            {: dl.add(d); RESULT = dl; :}
                    | decl_list:dl exp:e
                            {:dl.add(e); RESULT = dl; :}
                    ;

decl              ::= REC_DECL NAME:name
                          {: RESULT = "(STRUCT " + name + ")"; :}
                    | VAR_DECL NAME:name PARAM_ID NAME:type
                          {: RESULT = "(VAR " + name + " (TYPE " + type + ") "; :}
                    | PROC_DECL NAME:name LPAR decl_list:dl RPAR BEGIN decl_list:body END
                          {: RESULT = "(PROCEDURE " + name + " " + dl + body + ")"; :}
                    | NAME:name PARAM_ID NAME:type
                          {: RESULT = "(PARAM " + name + " type: " + type + ")"; :}
                    ;

/* Expressions needs work. Check that we're not missing rules*/
exp               ::= exp log_op exp {: RESULT = "They look the same"; :}
                    | NOT exp:e {: RESULT = "(NOT " + e + ")"; :}
                    | exp rel_op exp {: RESULT = "They are related"; :}
                    | exp arit_op exp {: RESULT = "Maths"; :}
                    | literal:lit {: RESULT = "" + lit; :}
                    | call_stmt   {: RESULT = ""; :}
                    | NEW NAME:name {: RESULT = name; :}
                    | var:v {: RESULT = "" +v; :}
                    | LPAR exp RPAR {: RESULT = "Nested things"; :}
                    ;

literal           ::= STRING_LITERAL:str {: RESULT = str; :}
                    | INT_LITERAL:i {: RESULT = i; :}
                    | FLOAT_LITERAL:f {: RESULT = f; :}
                    | bool:b {: RESULT = b; :}
                    | NULL {: RESULT = "null"; :}
                    ;

rel_op            ::= LT | LTEQ | GT | GTEQ | EQ | NEQ
                    ;

arit_op           ::= ADD | MINUS | MULT | DIVIDE | EXPONENT
                    ;

bool              ::= TRUE | FALSE
                    ;

log_op            ::= AND | OR
                    ;


/* Statements - need to be adjusted to allow for optional value */
stmts             ::= stmts stmt
                   | stmt
                   ;

stmt              ::= assign_stmt
                    | if_stmt
                    | while_stmt
                    | return_stmt
                    | call_stmt
                    ;

assign_stmt       ::= var ASSIGN_OP exp
                    | deref_var ASSIGN_OP exp
                    ;

if_stmt           ::= IF exp THEN stmts FI
                    | IF exp THEN stmt stmts FI
                    ;

while_stmt        ::= WHILE exp DO stmts OD
                    ;

return_stmt       ::= RETURN exp
                    ;

/* call_stmt         ::= NAME LPAR exp RPAR 
                    ; */

/* Vars, refs and derefs */

var               ::= NAME | exp DOT NAME
                    ;

ref_var           ::= REF LPAR var RPAR
                    ;

deref_var         ::= DEREF LPAR var RPAR
                    | DEREF LPAR deref_var RPAR
                    ;

type              ::= FLOAT | INT | STRING | BOOL
                    ;
