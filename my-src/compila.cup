/*
Ambiguous grammar version with precedence rules
*/
import java_cup.runtime.*;
import java.io.FileReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.ByteArrayInputStream;
import java.util.*;

parser code
{:
public void syntax_error(Symbol s) {
    System.err.printf("Syntax error on: [line: %s, column: %s, value: %s]\n",
                                s.left + 1, s.right + 1, s.value);
}
:};

scan with {: return getScanner().next_token(); :};

terminal                           PROGRAM;
terminal                           BEGIN, END, IN;
terminal                           LPAR, RPAR, SEMI, COMMA, LCURLY, RCURLY;
terminal                           REC_DECL, PROC_DECL, VAR_DECL, NEW;
terminal                           IF, FI, THEN, ELSE, WHILE, DO, OD, RETURN, REF, DEREF;
terminal String                    INT_LITERAL, STRING_LITERAL, FLOAT_LITERAL;
terminal                           TRUE, FALSE, NULL;
terminal                           DOT, PARAM_ID, ASSIGN_OP;
terminal                           NOT;
terminal                           LT, LTEQ, GT, GTEQ, EQ, NEQ;
terminal                           ADD, MINUS, MULT, DIVIDE, EXPONENT;
terminal                           AND, OR;
terminal String                    FLOAT, INT, STRING;
terminal String                    NAME;
nonterminal String                 call_stmt;
nonterminal String                 stmt, assign_stmt, if_stmt, while_stmt;
nonterminal String                 return_stmt, literal;
nonterminal Program                program;
nonterminal String                 decl, var_decl, proc_decl, rec_decl;
nonterminal String                 paramfield_decl, type;
nonterminal String                 rel_op, log_op, arit_op;
nonterminal String                 exp, bool, var, ref_var, deref_var;
nonterminal LinkedList<String>     decl_list, stmt_list, param_list_semi;
nonterminal LinkedList<String>     param_list_comma, exp_list;

precedence left                    OR;
precedence left                    AND;
precedence right                   NOT;
precedence nonassoc                LT, LTEQ, GT, GTEQ, EQ, NEQ;
precedence left                    ADD, MINUS;
precedence left                    MULT, DIVIDE;
precedence right                   EXPONENT, LPAR;
precedence left                    DOT;

start with program;

program           ::= PROGRAM NAME:name BEGIN decl_list:dl END
                               {: LinkedList<LinkedList> l = new LinkedList<>();
                                  l.add(dl);
                                  RESULT = new Program(name, l);
                                  System.out.println(RESULT.printAst()); :}
                    ;

decl_list         ::= decl:d {: LinkedList<String> l = new LinkedList<>();
                                l.add(d);
                                RESULT = l; :}
                    | decl_list:dl SEMI decl:d {: dl.add(d); RESULT = dl; :}
                    | 
                    ;

stmt_list          ::= stmt:s {: LinkedList<String> l = new LinkedList<>();
                                 l.add(s);
                                 RESULT = l; :}
                    | stmt_list:sl SEMI stmt:s {: sl.add(s); RESULT = sl; :}
                    |
                    ;

param_list_semi   ::= paramfield_decl:p {: LinkedList<String> l = new LinkedList<>();
                                           l.add(p);
                                           RESULT = l; :}
                    | param_list_semi:pl SEMI paramfield_decl:p
                                         {: pl.add(p); RESULT = pl; :}
                    |
                    ;
param_list_comma  ::= paramfield_decl:p {: LinkedList<String> l = new LinkedList<>();
                                           l.add(p);
                                           RESULT = l; :}
                    | param_list_comma:pl COMMA paramfield_decl:p
                                          {: pl.add(p); RESULT = pl; :}
                    |
                    ;
                    
exp_list          ::= exp:e {: LinkedList<String> l = new LinkedList<>();
                                          l.add(e);
                                          RESULT = l; :}
                    | exp_list:el COMMA exp:e {: el.add(e); RESULT = el; :}
                    |
                    ;

decl              ::= rec_decl:d {: RESULT = d; :}
                    | proc_decl:d {: RESULT = d; :}
                    | var_decl:d {: RESULT = d; :}
                    ;

var_decl          ::= VAR_DECL NAME:name PARAM_ID type:t {: RESULT = "var " + name + ": "
                                                            + t; :}
                    ;

rec_decl          ::= REC_DECL NAME:name LCURLY param_list_semi:pl RCURLY
                               {: RESULT = "struct " + name + ": " + pl; :}
                    ;

paramfield_decl   ::= NAME:name PARAM_ID type:t {: RESULT = "param " + name + ": " + t; :}
                    ;

proc_decl         ::= PROC_DECL NAME:name
                                LPAR param_list_comma:pl RPAR
                                BEGIN decl_list:dl
                                IN stmt_list:sl END
                                {: RESULT = "procedure " + name + pl + "\n\t " + dl +
                                   "\n\t " + sl; :}
                    | PROC_DECL NAME:name
                                LPAR param_list_comma:pl RPAR
                                PARAM_ID type
                                BEGIN decl_list:dl
                                IN stmt_list:sl END
                                {: RESULT = "procedure " + name + pl + "\n\t " + dl +
                                   "\n\t " + sl; :}
                    ;

/* Expressions needs work. Check that we're not missing rules*/
exp               ::= exp:e1 log_op exp:e2  {: RESULT = e1 + " " + e2; :}
                    | NOT exp:e             {: RESULT = e; :}
                    | exp:e1 rel_op exp:e2  {: RESULT = e1 + " " + e2; :}
                    | exp:e1 arit_op exp:e2 {: RESULT = e1 + " " + e2; :}
                    | literal:lit           {: RESULT = lit; :}
                    | call_stmt:s           {: RESULT = s; :}
                    | NEW NAME:name         {: RESULT = name; :}
                    | var:v                 {: RESULT = v; :}
                    | ref_var:v             {: RESULT = v; :}
                    | deref_var:v           {: RESULT = v; :}
                    | LPAR exp:e RPAR       {: RESULT = e; :}
                    ;

literal           ::= STRING_LITERAL:str {: RESULT = str; :}
                    | INT_LITERAL:i {: RESULT = i; :}
                    | FLOAT_LITERAL:f {: RESULT = f; :}
                    | bool:b {: RESULT = b; :}
                    | NULL {: RESULT = "null"; :}
                    ;

rel_op            ::= LT | LTEQ | GT | GTEQ | EQ | NEQ
                    ;

arit_op           ::= ADD | MINUS | MULT | DIVIDE | EXPONENT
                    ;

bool              ::= TRUE | FALSE
                    ;

log_op            ::= AND | OR
                    ;


/* Statements - need to be adjusted to allow for optional value */

stmt              ::= assign_stmt:a {: RESULT = a; :}
                    | if_stmt:i     {: RESULT = i; :}
                    | while_stmt:w  {: RESULT = w; :}
                    | return_stmt:r {: RESULT = r; :}
                    | call_stmt:s   {: RESULT = s; :}
                    ;

assign_stmt       ::= var ASSIGN_OP exp               {: RESULT = "assign"; :}
                    | deref_var ASSIGN_OP exp         {: RESULT = "derefassign"; :}     
                    ;

if_stmt           ::= IF exp THEN stmt_list:l FI        {: RESULT = "\n\t\tif\n\t\t\t" +l; :}
                    | IF exp THEN stmt_list:l ELSE stmt_list:l2 FI
                                                      {: RESULT = "\n\t\tif\n\t\t\t" +
                                                         l + "\n\t\telse\n\t\t\t" + l2;:}
                    ;

while_stmt        ::= WHILE exp:e DO stmt_list:l OD       {: RESULT =
                                                         "\n\t\twhile "+ e + "\n\t\t\t" +l
                                                         + "\n\t\tdo\n\t\t\t" + l
                                                         + "\n\t\tod\n\t\t"; :}
                    ;

return_stmt       ::= RETURN exp:e {: RESULT = e; :}
                    | RETURN
                    ;

call_stmt         ::= NAME:name LPAR exp_list RPAR {: RESULT = name;:}
                    ;

/* Vars, refs and derefs */

var               ::= NAME | exp DOT NAME
                    ;

ref_var           ::= REF LPAR var RPAR
                    ;

deref_var         ::= DEREF LPAR var RPAR
                    | DEREF LPAR deref_var RPAR
                    ;

type              ::= FLOAT:f {: RESULT = f; :}
                    | INT:i {: RESULT = i; :}
                    | STRING:s {: RESULT = s; :}
                    | bool:b {: RESULT = b; :}
                    | NAME:n {: RESULT = n; :}
                    | REF LPAR type:t RPAR {: RESULT = t; :}
                    ;
