\documentclass[10pt,freeform]{handout}[2014/08/13]

\input{coursedata}
\input{preamble}
\pgfdeclareimage[height=2.4cm,interpolate=true]{uio}{uiologo}%% relative
%\usepackage[german]{babel} 
%\usepackage{german}

\handouttitle{Oblig 1}
\handoutnumber{1}
\issuedate{12.\ 02.\ 2019}
\topic{About the lecture}




\begin{document}
\thispagestyle{empty}

\section{Official grading guidelines}
\label{sec:official-info}




\hrulefill{}

The \textbf{deadline/frist}  for the oblig is

\begin{quote}
  \textbf{\deadlineone, 23:59}
\end{quote}

Requirements:


\begin{itemize}
\item the testprogram parses 100\% ok (see below)
\item the printed AST reflects the correctly parsed structure (especially,
  the correct associativity and precedence). The exact same formatting as
  in the provided illustration is not required; reasonable deviations are
  fine.
\item the instructions under ``What and how to  hand-in'' need to be followed
\item the solution needs to compile and run \emph{at the UiO
    pool}.\footnote{Statements like ``but on my laptop it worked, I can show
    you'' don't cut it \ldots.} Test it!
\end{itemize}

\hrulefill




\section{What and how to hand in}
\label{sec:what-how}


\subsection{Git}
\label{sec:git}



This year, we try whether handing it in via 
\begin{quote}
  \textsl{git}   
\end{quote}
is a good way. In previous years it was mostly via email, 2017 via devilry,
but since it's about a a piece of software, this year we use git (as 2018).
I assume that most are in principle familiar with \texttt{git}, if not, ask
me (or bring yourself up to speed otherwise).  I suggest, that we use the
uio-internal git server\footnote{Actually, it's the UiO enterprise github
  server. Github is just one particular ``web-interface'' on top of git and
  there are also alternatives on the market, but for uniformity, let's just
  stick to the UiO github server.}

\begin{quote}
  \url{github.uio.no}
\end{quote}


In order to hand-in via git, each group has to do the following steps.

\begin{enumerate}
\item everyone: if not already: create yourself a account at
  \url{github.uio.no}. You UiO login allows you to do that. 
\item per group: \emph{create} a new \emph{project}.  If your are in group
  number $n$,\footnote{The project names need to be different so that, for
    correction, one can distinguish them by their ``name'' (not that all
    projects are called ``compila'')}
  \begin{quote}
    call your project \texttt{compila<n>}
  \end{quote}
  The ``parentheses'' \texttt{<} and \texttt{>} are \emph{not} part of the
  name! If the group contains more than one person, the creator has to add
  the partner as \emph{collaborator} 
\item Assuming that the project is ``private'': add me as collaborator
  (login \texttt{msteffen}). I don't need to contibute as collaborator, but
  I need access.
\item Send me an \emph{email} with the link, mentioning the names (and
  login) of the members of the group as confirmation. That needs to be done
  at latest \emph{before the deadline}.The names of the member of the group should als
  feature \emph{prominently} on the top-level of the repository, as in the
  top-level \texttt{Readme}.
\end{enumerate}

\subsection{What to include into a solution}
\label{sec:what-include-into}


\begin{itemize}
\item A top-level \emph{Readme-file} containing
  \begin{itemize}
  \item  containing names and emails of the authors
  \item instructions how to build the compiler and how to run it.
  \item test-output for running the compiler on \texttt{compila.cmp} as
    input
  \item of course, all code needed to run your package. That includes
    \begin{itemize}
    \item \textsl{JFlex}-code for the scanner
    \item \textsl{CUP}-cpde for the 2 variants of the syntax
    \item the Java-classes for the syntax-tree
    \item the build-script \texttt{build.xml}\footnote{Alternatively, you
        can use a makefile if you prefer that. In that case, remove the
        \texttt{build.xml}-file.}
    \end{itemize}
  \end{itemize}


\end{itemize}



\section{Purpose and goal}
\label{sec:x}

The goal of the task is to gather practical experience of the following
tools and technies.
\begin{itemize}
\item use scanner/lexer and parser tools. In this case \texttt{JFLex} and
  \texttt{CUP}.
\item rewrite and massage a grammar given in one form into another one so
  that it's accepted by the tools. In our case, the language is given in
  some EBNF, which has to be adequately rewritten so that it can be fit
  into the lexer and parser tools
\item handle associativity and precedence of syntactic contructs in two
  possible ways
  \begin{itemize}
  \item formulate a (unambiguous) grammar that embodies the correct
    precendences and associativies
  \item work with an ambiguous grammar, but instruct the parser tool (like
    CUP) to result in an appropriate parser.
  \end{itemize}
\item design and implement an suitable AST data structure.  Use the parser
  to output your AST (in case of a successful parse).
\item do a ``\emph{pretty printer}'' in the following sense: implement some
  functionality that \emph{outputs} and AST in a ``useful'' manner. In
  particular, the parenthetic tree structure must be visible from the
  output (i.e., one can see whether the associativity and the precedence is
  correctly implemented). 
\end{itemize}


\section{Tools}
%\label{sec:tools}

The platform is \emph{Java}, together with the auxiliary tools

\begin{itemize}
\item \textsl{JFlex} (scanner generator in the (f)lex family)
\item \textsl{CUP} (parser generator in the yacc family)
\item \textsl{ant} (a kind of ``make'' tool specialized for Java)
\end{itemize}


The tool ant is available at the RHEL pool at IFI, for other platforms I
don't know, but it's freely available. \textsl{JFlex} and \textsl{CUP} are
provided.

If, for some reason, you plan to deviate from the suggested tools, you
\begin{enumerate}
\item \textbf{MUST} discuss that first with the lecturer/
\item it \textbf{must} be a platform which is freely available at the
  university RHEL pool resp. is  platform independent. Proprietary tools or
  tools I don't have easy\footnote{I \emph{mean} easy and in the sense that
    it does not cost time to install the required environment or to figure
    out how it all hangs together. \emph{Not} ``easy'' as in ``it's really
    not hard after you read some manuals and with the help from the fine
    folks on stack-exchange'' \ldots} access to cannot be used. If using Java, it
  must compile and run without support of specific development environments
  or ``frameworks'' besides the ones mentioned (\textsl{JFlex},
  \textsl{CUP}, \textsl{ant}).
\end{enumerate}



\section{Task more specifically: Syntax check and parsing}
\label{sec:task-more-spec}


The overal task is to 

\begin{quote}
  implement a parser for the \textsl{Compila 19} language.
\end{quote}
The language specification is given in a separate document. Oblig 1 is
concerned with checking \emph{syntactic correctness}, which means, not all
of the language specification is relevant right now: semantic correctness,
type checking etc. will become relevant only later for the second oblig.


\subsection{Syntax tree}
\label{sec:syntax-tree}

The result of a successful parse is an \emph{abstract syntax tree}. That
data structure needs to be appropriately ``designed''. In a Java
implementation, that involves the definition of appropriately chosen
classes arranged in some class hierarchy. Make also use if \emph{abstract
  classes}. In the lecture, there had been some ``design guidelines'' that
may be helpful. Carefully chosen names for classes will help in a
conceptually clear implementation. A definitely \emph{non-recommended} way
is to have one single class \texttt{Node} lumping together all kinds of
nodes and syntactic categories in the syntax tree.









\subsection{Print out of the AST}
\label{sec:print-out-ast}


The AST should be ``printed''. The easiest and recommeded form of printout
is in \emph{prefix form}. Under \texttt{material/sample-compila-ast}, there
is an example compila input file and a corresping file containing a
possible output. The two files are called

\begin{itemize}
\item \texttt{complexaddition.cmp}
\item \texttt{complexaddition.ast}
\end{itemize}


Note: the two files are meant as \emph{inspiration.} Each year the syntax
of \textsl{compila} slightly changes (wrt. keywords, associativity etc). So
the syntax is 100\% in accordance with the 2019 version (but pretty
comparable).

The one that should be used for this task (AST-printing) is the following

\begin{quote}
  \texttt{./src/tests/fullprograms/complexaddition.cmp}  
\end{quote}

and it should be consistent with this year's gammar (fingers crossed).



It's allowed (but not necessary) to print it in other forms than prefix
form. But the output must indicate the AST in readable form (``readable''
as in human-readble that is \ldots). Note, the task is not that the output
is a syntactically correct \textsl{compila} program again (that might be a
formatting tool), we just need a way to look at the syntax tree, which
comes in handy for debugging,


%\bibliographystyle{apalike}
%{\small
% \bibliography{string,semantics,crossref}
%% \bibliography{extracted}
% }

\subsection{Two grammars}
\label{sec:two-grammars}


As mentioned shortly, the task requires 2 grammars, representing 2 ways
dealing with precendence and associativity.

\begin{enumerate}
\item an \emph{unambiguuous} grammar resolving precedence and associativity
  by ``baking it in'' directly into the grammar. The grammar is in plain
  BNF (in the form required by the tools)
\item the second grammar is ambiguous and relies on \emph{CUP} to resolve
  the associativity and precendence. This second grammar will probably look
  nicer and will be shorter. It's therefore probably best to take that one
  as \emph{default} (for instance for oblig 2).
\end{enumerate}

\subsubsection*{Comparison and discussion}
\label{sec:comparison}

Investigate and characterise \emph{conflicts} of the \emph{original}
grammar. How many states do the 2 generated CUP grammars have? That
requires a look into the CUP-generated code. Discuss also whether the
choice of the two grammars influences the generation of the AST: is one of
the two approaches easier to work with when it comes to generate an AST
(resp. your chosen AST data structure.


\textbf{Note:} It's not required to provide code to build \emph{two}
versions of AST-generation, one is enough. In other words, for one of the
two grammars, you don't need ``action code'' in the grammar to produce an
AST, plain \emph{checking} is sufficient.

\subsection{Lexical analysis}
\label{sec:lexical-analysis}

As mentioned, \textsl{JFLex} is the tool of choice for lexical analysis. It
delivers a token to the parser via the method \texttt{next\_token()}.  

As far the the ``theoretical'' task concerning \textsl{compila 19} is
concerned, the lexer is responsible for ignoring comment, white-space etc,
find keywords and the like. 

Besides that, one has to make the parser and the lexer ``work together''
hand in hand. Information about that can be found in the corresponding
manual. There should also be examples for inspiration. A crucial ingredient
is the interface \texttt{java\_cup.runtime.Scanner} which needs to be
implemented by the actual scanner. The scanner will hand over tokens of the
type \texttt{Symbol} and one can use \texttt{Symbol.value} to pass ``text''
or other objects from the lexer to the parser.



\subsection{Error handling}
\label{sec:error-handling}

Error handling can be done simple: When hitting an error, parsing should
stop (as opposed to try to continue and give back an avalanche of
subsequent errors). Some meaningfull error message (at least wrt. which
syntactic class caused the error) would be welcome, as opposed to a plain
``sorry, bad program''. It's not required to give back line numbers
referrring to the original source code or positions in the original
file. In practice that's definitely useful (and not very hard either), but
not required for the oblig.




\subsection{Tests}
\label{sec:tests}

For testing, there is a bunch of files under

\begin{quote}
  ./src/tests
\end{quote}

They are supposed to contain syntactically correct programs for this year's
version, with exception of the ones under
\begin{quote}
  \texttt{./src/tests/errors}
\end{quote}


For oblig one, you are requested to generate the 
\begin{quote}
  \texttt{./src/tests/fullprograms/complexadditions.cmp}  
\end{quote}
as part of the oblig as mentioned, but you may of course use the other test
program to see how robust your implementation is. Especially the
error-programs later will become relevant for oblig2, when we do type
checking; there, some syntactically ok programs should be flagged as
erroneous by the type checker.







\section{Resources}
\label{sec:resources}

The web-page (the git-one) will contain also links to \textsl{JFlex}
\textsl{CUP} and corresponding manuals.






\end{document}

Model Checking Cache Coherence Protocols for Distributed File Systems

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
